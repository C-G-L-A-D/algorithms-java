![image.png](https://gitee.com/roada/drawingBed/raw/main/blog/1699495903012-9408ce2d-d4b7-45d5-9bac-f10f979dc39f.png)
## 解法一：
### 实现思路：
本题不能使用除法。需要计算除指定元素外的其他数组元素的乘积。可以将指定元素作为分界线，将左右两边划分为子数组，将左右两边子数组的乘积总和相乘就能得到结果。通过前缀和技巧进行延伸，左边子数组乘积我们可以通过数组的**前缀积**得到；而右边子数组乘积，通过反向计算获取数组的后缀积得到。
### 实现步骤：

1. 纪录数组长度；
2. 创建前缀积数组，循环遍历数组计算每个元素对应的前缀积；
   1. 前缀积第一个元素为原数组第一个元素；
   2. 除第一个元素外，其他前缀积等于前一个元素对应的前缀积乘以当前元素；
3. 创建后缀积数组，从末尾开始循环遍历数组计算每个元素对应的前缀后；
   1. 后缀积末尾第一个元素为原数组末尾第一个元素；
   2. 除末尾第一个元素外，其他后缀积等于上一个元素对应的后缀积乘以当前元素；
4. 创建最后结果数组，最后结果数组的第一个元素等于后缀积数组的第二个数（排除原数组第一个元素）；最后结果数组的最后一个元素等于前缀积末尾第二个元素（排除原数组末尾第一个元素）。
5. 遍历数组（除正书和倒数第一个元素外）；
   1. 每个元素对应的最后乘积结果等于上一个元素的前缀和乘以下一个元素的后缀和；
6. 遍历完成，返回最后结果数组。
### 实现代码
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;

        int[] prefix = new int[n];
        prefix[0] = nums[0];
        // 获取前缀积
        for (int i = 1; i < nums.length; i++) {
            prefix[i] = prefix[i - 1] * nums[i];
        }

        int[] suffix = new int[n];
        suffix[n - 1] = nums[n - 1];
        // 获取后缀积
        for (int i = n - 2; i >= 0; i--) {
            suffix[i] = suffix[i + 1] * nums[i];
        }

        int[] res = new int[n];
        res[0] = suffix[1]; // 排除索引 0 
        res[n - 1] = prefix[n - 2]; // 排除索引 n - 1
        for (int i = 1; i < n - 1; i++) {
            res[i] = prefix[i - 1] * suffix[i + 1];
        }

        return res;
    }
}
```

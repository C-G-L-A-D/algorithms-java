![image.png](https://gitee.com/roada/drawingBed/raw/main/blog/1697622772250-8f507045-f882-4453-b423-9e2fbd3a9b41.png)
## 解法一：
### 实现思路：
回文字符串的特性是字符串的原序和反序相同，也就是说字符串到序后还和原字符串相同。而[反转字符串](https://www.yuque.com/u26951862/petxba/omwsdp442figau28)只需要以中心元素为轴，交换两边的元素即可。由上述信息可知，回文子串从中心节点向左右两边依次进行遍历，每个元素均相同。<br />因此我们可以字符串所有元素都作为回文子串的中心元素，从中心元素的左右两边相向而行找出该中心元素所在的最长回文子串。然后再比较这些回文子串的长度来找到最长的回文子串并返回。<br />但需要注意的是，回文子串可以是奇数或偶数，奇数字符串的中心元素只有一个，而偶数字符串的中心元素有两个。因此还需要获取所有相邻元素为中心元素的最长回文子串进行比较。<br />从头开始遍历字符串时，当前元素和下一个元素为相邻元素。因此在遍历每个元素时，以当前元素作为中心元素时，可以找到该元素所在的最长奇数回文子串；以当前元素和下一个元素作为中心元素时，可以找到这两个相邻元素所在的最长偶数回文子串。
### 实现步骤：

1. 创建一个用于记录最长回文子串的长度和字符串；
2. 循环遍历字符串每个元素；
   1. 找到当前元素为中心元素的最长奇数回文子串；
      1. 从中心元素左右两边开始延伸依次判断元素是否相同，不相同则回文子串到上一次结束。
   2. 找到当前元素和下一个元素为中心元素的最长偶数回文子串；
      1. 从中心元素左右两边开始延伸依次判断元素是否相同，不相同则回文子串到上一次结束。
   3. 比较当前最长奇数回文子串和记录的最长回文子串的长度大小；
      1. 记录的值较大，不做任何处理，继续下一步；
      2. 当前最长奇数回文子串的长度较大，将记录的最长回文子串赋值为当前最长奇数回文子串，并修改记录的最长回文子串长度为当前最长奇数回文子串长度；
   4. 比较当前最长偶数回文子串和记录的最长回文子串的长度大小；
      1. 记录的值较大，不做任何处理，继续下一步；
      2. 当前最长偶数回文子串的长度较大，将记录的最长回文子串赋值为当前最长偶数回文子串，并修改记录的最长回文子串长度为当前最长偶数回文子串长度；
3. 遍历结束，返回最长回文子串。
### 实现代码
```java
// 遍历数组，以每个元素为回文子串的中心元素，向两边延伸判断该回文子串的长度。
// 向两边延伸判断是因为回文子串的反序和原序相同，则从回文子串的中心元素两边延伸，左右两子串均相同
// ps: 当回文子串为奇数时，中心元素有一个；为偶数时，中心元素有两个

class Solution {
    public String longestPalindrome(String s) {
      int maxLen = 0;
      String maxString = "";
      for(int i = 0; i < s.length(); i++) {
        // 以字符串中元素索引为 i 的元素作为中心元素的回文子串，长度为奇数
        String s1 = palindrome(s, i, i);
        // 以字符串中元素索引为 i 和 i + 1 的元素作为中心元素的回文子串，长度为偶数
        String s2 = palindrome(s, i, i + 1);

        if(s1.length() > maxLen) {
          maxLen = s1.length();
          maxString = s1;
        }

        if(s2.length() > maxLen) {
          maxLen = s2.length();
          maxString = s2;
        }
      }
      return maxString;
    }

    /**
     * 找出指定中心元素的回文子串
     * @param(String) s - 数组
     * @param(int) l - 中心元素左边遍历索引
     * @param(int) r - 中心元素右边遍历索引
     * 从中心节点两边开始相向遍历判断，如果 l 位置的元素 和 r 位置的元素不相同，则说明回文子串到上一次遍历结束
     */
    String palindrome(String s, int l, int r) {
      while(l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
        l--;
        r++;
      }
      // 遍历结束，回文子串的范围为 l + 1 ～ r - 1
      return s.substring(l + 1, r);
    }
}
```

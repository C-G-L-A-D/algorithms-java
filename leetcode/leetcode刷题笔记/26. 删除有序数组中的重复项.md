![image.png](https://cdn.nlark.com/yuque/0/2023/png/27354749/1697527065261-7ecaa4a7-18d1-4a52-a6fb-d78feb302e38.png#averageHue=%23f6f6f6&clientId=u937c5537-1ee9-4&from=paste&height=1240&id=u41fdc841&originHeight=1240&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&size=238819&status=done&style=none&taskId=udc0d4b32-27b7-4aab-b107-084c9807e58&title=&width=1432)
## 解法一：
### 实现思路：
因为数组是有序递增数组，只需要通过遍历判断遍历的当前元素是否比最新纪录的元素值大，就可以保证所有被记录的数据都不重复。但由于题目要求只能在**原地**修改，就代表不能通过将不重复元素存入新数组。因此解题关键在于如何记录不重复的元素，本解法通过快慢指针法进行解答。<br />当指针遍历数组时会一直向前进，因此在指针之前的元素发生改变时也不会影响指针遍历数组，因此我们可以将不重复的元素提取出来按顺序放到指针前的数组位置中，就解决了不重复的元素的记录问题。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27354749/1697531204478-b20d2ac9-c84c-4f5e-a349-054eb8eb21cd.png#averageHue=%23f9f9f9&clientId=ucace2fe1-e724-4&from=paste&id=SZenN&originHeight=620&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34633&status=done&style=none&taskId=ud0c85cb8-620a-45af-b6d8-0de93739a1f&title=)<br />同时我们可以新建另外一个指针用来指向去重数组中最新被添加的元素（初始可默认为原数组第一个元素）。而在有序数组中，两个指针指向的元素只会有较大或相同的可能性，因此只要筛选出哪个元素比去重数组中最新被添加的元素值大，就说明该元素可以被添加到去重数组中，相同值的元素跳过就好。<br />过程如下图所示：

![yuque_diagram.png](https://cdn.nlark.com/yuque/0/2023/png/27354749/1697529748312-7b073d76-eb79-4e59-9eb0-9ee3f73a1f65.png#averageHue=%23434343&clientId=ucace2fe1-e724-4&from=ui&id=u72572bc4&originHeight=2914&originWidth=1956&originalType=binary&ratio=1&rotation=0&showTitle=false&size=437967&status=done&style=none&taskId=u38a6a60a-e0d9-4c52-9476-46ef9c9c814&title=)

### 实现步骤：

1. 判断数组是否为空；
   1. 数组为空，返回0，
   2. 不为空，执行下面操作；
2. 创建快慢两指针，初始值为数组开头索引 0 ；
3. 快指针循环遍历数组，并依次比较快指针指向的元素值和慢指针指向的元素值，直至遍历完成；
   1. 当快指针指向的元素值比慢指针指向的元素值大，则慢指针前进一位，并将该位置的值设置为快指针指向的元素值。随即继续循环；
   2. 比较值相同，继续循环；
4. 循环结束，返回慢指针的索引位置。
### 实现代码
```java
class Solution {
    public int removeDuplicates(int[] nums) {
				// 限制条件
				if(nums.length == 0) {
					return 0;
				}
			
        int fast, slow;
        // 记录索引位置
        fast = slow = 0;

        for(; fast < nums.length; fast++) {
            // 获取不重复的元素
            if(nums[fast] > nums[slow]) {
								// 先前进再赋值，因为 nums[0]可直接录入
                nums[++slow] = nums[fast];
            }
        }
        return ++slow;
    }
}
```

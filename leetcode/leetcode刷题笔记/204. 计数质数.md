
## 解法一：
### 实现思路：
找到能整除该整数的所有因子来判断是否只包含 1 指定整数本身，从而确定该数是否是素数。因此我们可以通过数学技巧缩小因子范围，再循环因子范围来找到所有因子。<br />一个数的因子范围为 [1, x]（x 为该数）。已知因子有 1 和该数本身，因此范围可缩小为 [2, x)。两数相乘等于 x，那么相乘的两个数 m 和 n 的关系必然是 m <= n 。因此我们找到 m 或者 n 就可以找到另外一个数相乘的到 x 。因此范围可以再缩小，只寻找到较小一半的因子就好，即确认 [2, m] 。 所以如何确定 m 是解题关键。<br />已知 m 须与 n 相乘得到 x，而 m <= n ，因此 m 的最大值是 m 与 n 相等的时候。所以可确定 m 的最大值是 sqrt(x) 「sqrt() 求平方根」。<br />最终确定寻找因子的范围是  [2, sqrt(x)]。时间复杂度为 `O(sqrt(N))` 。
### 实现步骤：

1. 循环遍历小于给定整数 n 的数；
   1. 循环 [2, sqrt(x)] 找到所有能整除 x 的因子；
      1. 找到，则说明不是素数；
      2. 没找到，则说明是素数；
2. 返回所有小于 n 的素数。
### 实现代码
```java
class Solution {
    public int countPrimes(int n) {
        
        int count = 0;
        for(int i = 2; i < n ; i++) {
            if(isPrime(i)) {
                count++;
            }
        }
        return count;
    }

    boolean isPrime(int n) {
        for(int i = 2; i * i <= n; i++) {
            if(n % i == 0) {
                return false;
            }
        }
        return true;
    }
}
```
## 解法二「解法一的优化-埃拉托色尼选筛法」
### 实现思路
埃拉托色尼选筛法(the Sieve of Eratosthenes)简称埃氏筛法，是由埃拉托色尼提出的解决求取一定范围内素数的方法。筛选次数的时间复杂度为 `O(nloglogn)` 。埃拉托色尼选筛法的主要思路是**把不大于根号n的所有素数的倍数剔除，剩下的就是素数。**<br />我们知道素数的倍数不可能是素数，因此我们在找到一个素数时就可以将他的倍数排除，提高算法的时间复杂度。<br />筛选素数的倍数时，为避免冗余，可以从**元素的平方**开始遍历 **小于指定值** 的 **该元素的倍数**，从而避免 `2 * 3` 和 `3 * 2` 这类情况被重新标记。<br />假设寻找小于 n 的素数。那么可以遍历 [2, n) 范围内的每个元素，而在遍历时，当前元素 x 的因子必然都在 [1, x] 范围内，x 也可能是 (x, n) 范围内某个元素的因子。因此，可以在遍历时，将每个元素作为因子，将  [2, n) 范围内，是因子倍数的元素排除，剩余的元素必定就是素数。<br />![](https://gitee.com/roada/drawingBed/raw/main/blog/1698717399561-b1250758-b725-4cb5-adc9-c8deff37ce46.jpeg)<br />同时，与解法一的思路相同，如果当前元素 x 作为因子，可进一步缩小 x 的取之范围为 sqrt(x) 。因为之后的元素为因子找到的乘积也是重复的，可以剔除。
### 实现步骤

1. 创建长度为 n 的数组记录是否素数，数组的索引下标对应数字，每个元素的初始值都设置为true，找出不是素数的元素，修改该元素在数组中对应的值为 false；
2. 已知 1 不是是素数，因此可以从 2 开始到 sqrt(n) 依次遍历数组，将每个索引下标作为因子，只要是该因子的倍数就不是素数；
   1. 如果该元素值为 true，需要判断该元素是否是素数；
      1. 从 **该元素的平方数开始**  将 **小于 n** 的 **该元素倍数** 的 **元素值** 都设置为 false。即假设该元素为 x， 遍历范围为 [x2 , n] ， 每次遍历自增 x （倍数）；
   2. 如果该元素值为 false，则说明该元素不是素数，继续循环；
3. 创建 count 值来记录一共有多少个素数，初始值为0。从 2 开始到 n 依次遍历数组中每个元素的值；
   1. 如果该元素值为 true，则说明该元素是素数， count + 1；
   2. 如果该元素值为 false，则说明该元素不是素数，继续循环；
4. 返回 count 。
### 实现代码
```java
class Solution {
    public int countPrimes(int n) {
        boolean[] isPrimes = new boolean[n];
		Arrays.fill(isPrimes, true);

		// 将每个元素下标都当作素数，作为因子
		for(int i = 2; i * i <= n; i++) {
			// 2是素数，索引下标为 2的倍数 的元素都不是素数，依次类推。
			if(isPrimes[i]) {
				// 剔除因子的倍数元素，不是素数
				for(int j = i * i; j < n; j += i) {
					isPrimes[j] = false;
				}
			}
		}

		int count = 0;
		// 统计素数个数
		for(int i = 2; i < n; i++) {
			if(isPrimes[i]) count++;
		}

		return count;
    }

}
```

![image.png](https://gitee.com/roada/drawingBed/raw/main/blog/1717145063497-b95da643-8685-4890-9d5e-e4140c9011d5.png)
## 解法一：
### 实现思路：
指定长度 N 的字符串中找到相同的子串，子串的长度固定为 L。只需要维护滑动窗口大小为  L， 循环遍历字符串，找到所有长度为  L 的子串。将所有长度为 L 的子串中找到相同的子串进行记录。其中使用滑动窗口的时间复杂度为 O(N)，找到子串后进行截取，每次截取的时间复杂度为 O(L)，因此总的时间复杂度为 O(NL)。

不过可以优化截取子串的时机，使得截取子串次数减少，从而降低截取的时间复杂度。
      将 `A` `C` `G` `T` 转换为二进制数字串，截取子串可以转换成二进制数。
      每次滑动窗口变动时通过计算方式来更新二进制数，当滑动窗口的大小等于 L 时存储该二进制结果的出现次数。
      例如 A = 0； C = 1； G = 2； T = 3；则字符串 AAGTGAC = 000010111011
      只在滑动窗口的大小等于 L 且二进制结果出现不止一次时，才截取当前的位置的子串。
      此时截取字符串的次数可能会比每次滑动窗口都截取字符串的次数少得多。
### 实现步骤：

1. 创建一个长度可变的字符串数组，用于记录最后返回结果；
2. 获取指定字符串的长度 N;
3. 提前判断 N 是否小于指定子串的长度 L；
   1. 如果是，则无法找打到目标子串，返回 false；
   2. 如果不是，则继续以下步骤；
4. 创建变量 sum 用来记录滑动窗口内的二进制数总和，初始化值为 0 ；
5. 使用循环提前计算前 L - 1 个字符的二进制数总和；
   1. 每添加一个字符时，都将这个字符转换为两位二进制数，sum 都往左移动两位，腾出位置给当前字符；
   2. 再使用按位与运算将当前字符对应的二进制数添加到 sum 的后两位位置上；
6. 创建记录所有长度为 L 的子串对应的二进制数出现次数表；
7. 使用长度为 L 的滑动窗口遍历所有目标子串；
   1. 扩大滑动窗口，并计算当前滑动窗口内的子串对应的二进制数；
   2. 使用按位与运算，将当前 sum 限制在 2L 位内（一个字符对应两位二进制数）；
   3. 记录当前 sum 的出现次数；
   4. 如果当前 sum 的出现次数等于 2，则截取当前滑动窗口的子串，并添加到最终结果数组中；
8. 返回最终结果数组。
### 实现代码
```java
class Solution {

    static final int L = 10;

    // 映射字符对应的数字
    Map<Character, Integer> bin = new HashMap<Character, Integer>() {
        {
            put('A', 0);
            put('C', 1);
            put('G', 2);
            put('T', 3);
        }
    };

    public List<String> findRepeatedDnaSequences(String s) {
        // 用于存储结果
        List<String> ans = new ArrayList<String>();
        int n = s.length();
        if (n <= L) {
            return ans;
        }
        // 二进制值为 0000 0000
        int sum = 0;

        // 提前计算前 L-1 个字符对应的整数值
        for (int i = 0; i < L - 1; ++i) {
            /**
             * << 是左移位运算符，| 是按位或运算符。
             * 这一行代码的作用是将当前字符对应的数字编码追加到sum变量的尾部。
             * 在这里，通过左移2位操作为每个字符腾出两个比特位，然后使用按位或运算符将当前字符的编码值添加到sum中。
             * A：(0 << 2) | 0 = 0，二进制：0000
             * A：(0 << 2) | 0 = 0，二进制：0000
             * A：(0 << 2) | 0 = 0，二进制：0000
             * A：(0 << 2) | 0 = 0，二进制：0000
             * C：(0 << 2) | 1 = 1，二进制：0001
             * C：(1 << 2) | 1 = 5，二进制：0101
             * C：(5 << 2) | 1 = 21， 二进制：10101
             * A：(21 << 2) | 0 = 84，二进制：1010100
             * A：(84 << 2) | 0 = 336，二进制：101010000
             */
            sum = (sum << 2) | bin.get(s.charAt(i));
        }

				// 用于记录所有长度为 L 的子串对应的二进制数
        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();

				// 使用滑动窗口遍历所有目标子串
        for (int i = 0; i <= n - L; ++i) {
            // 相当于 left = i , right = i + L - 1, bin.get(s.charAt(i + L - 1))) 获取滑动窗口最后一位的字符，这样每次循环迭代时滑动窗口的大小都为 L
            sum = ((sum << 2) | bin.get(s.charAt(i + L - 1)));
            /**
             * 一个字符用两位二进制数表示， 1 << (L * 2)) - 1 相当于 L 位字符串转换为二进制数后的范围
             * & 是按位与运算，这一行代码表示将 sum 限制在 L 位数范围内
             */
            sum = sum & ((1 << (L * 2)) - 1);

            // 将滑动窗口内的二进制结果进行存储，如果已经存在该结果，则次数 + 1
            cnt.put(sum, cnt.getOrDefault(sum, 0) + 1);

            // 次数重复的结果，是目标子串
            if (cnt.get(sum) == 2) {
                // 此处截取字符串的次数 <= 每次滑动窗口都截取字符串的次数，因此可以减小时间复杂度
                ans.add(s.substring(i, i + L));
            }
        }
        return ans;
    }

}
```
